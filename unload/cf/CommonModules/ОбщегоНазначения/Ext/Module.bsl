
////////////////////////////////////////////////////////////////////////////////
// Вспомогательные процедуры и функции

// Выполнить экспортную процедуру по имени.
//
// Параметры
//  ИмяЭкспортнойПроцедуры – Строка – имя экспортной процедуры в формате 
//                                    <имя объекта>.<имя процедуры>, где <имя объекта> - это
//                                    общий модуль или модуль менеджера объекта.
// Параметры               - Массив - параметры передаются в процедуру <ИмяЭкспортнойПроцедуры>
//                                    в порядке расположения элементов массива.
// ОбластьДанных           - Число  - задает область данных, в которой необходимо выполнить процедуру.
// 
// Пример:
//  ВыполнитьБезопасно("МойОбщийМодуль.МояПроцедура");
//
Процедура ВыполнитьБезопасно(ИмяЭкспортнойПроцедуры, Параметры = Неопределено, ОбластьДанных = Неопределено) Экспорт
	
	// Проверка предусловий на формат ИмяЭкспортнойПроцедуры.       
	ЧастиИмени = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИмяЭкспортнойПроцедуры, ".");
	Если ЧастиИмени.Количество() <> 2 И ЧастиИмени.Количество() <> 3 Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Неправильный формат параметра ИмяЭкспортнойПроцедуры (%1)'"),
			ИмяЭкспортнойПроцедуры);
	КонецЕсли;

	ИмяОбъекта = ЧастиИмени[0];
	Если ЧастиИмени.Количество() = 2 И Метаданные.ОбщиеМодули.Найти(ИмяОбъекта) = Неопределено Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Неправильный формат параметра ИмяЭкспортнойПроцедуры (%1)'"),
			ИмяЭкспортнойПроцедуры);
	КонецЕсли;
		
	Если ЧастиИмени.Количество() = 3 Тогда
		ДопустимыеИменаТипов = Новый Массив;
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаКонстанты()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаРегистрыСведений()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаРегистрыНакопления()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаРегистрыБухгалтерии()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаРегистрыРасчета()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаСправочники()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаДокументы()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаОтчеты()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаОбработки()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаБизнесПроцессы()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаЖурналыДокументов()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаЗадачи()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаПланыСчетов()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаПланыОбмена()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаПланыВидовХарактеристик()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаПланыВидовРасчета()));
		ИмяТипа = ВРег(ЧастиИмени[0]);
		Если ДопустимыеИменаТипов.Найти(ИмяТипа) = Неопределено Тогда
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru='Неправильный формат параметра ИмяЭкспортнойПроцедуры (%1)'"),
				ИмяЭкспортнойПроцедуры);
		КонецЕсли;
	КонецЕсли;
	
	ИмяМетода = ЧастиИмени[ЧастиИмени.ВГраница()];
	ВременнаяСтруктура = Новый Структура;
	Попытка
		// Проверка на то, что ИмяМетода является допустимым идентификатором.
		// Например: МояПроцедура
		ВременнаяСтруктура.Вставить(ИмяМетода);
	Исключение
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Безопасное выполнение метода'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Неправильный формат параметра ИмяЭкспортнойПроцедуры (%1)'"),
				ИмяЭкспортнойПроцедуры);
	КонецПопытки;
	
	ПараметрыСтрока = "";
	Если Параметры <> Неопределено И Параметры.Количество() > 0 Тогда
		Для Индекс = 0 По Параметры.ВГраница() Цикл 
			ПараметрыСтрока = ПараметрыСтрока + "Параметры[" + Индекс + "],";
		КонецЦикла;
		ПараметрыСтрока = Сред(ПараметрыСтрока, 1, СтрДлина(ПараметрыСтрока) - 1);
	КонецЕсли;
	
	ВыполненаУстановкаРазделенияСеанса = Ложь;
	Если ОбщегоНазначенияПовтИсп.РазделениеВключено() Тогда
		Если Не ОбщегоНазначенияПовтИсп.СеансЗапущенБезРазделителей() Тогда
			Если ОбластьДанных = Неопределено Тогда
				ОбластьДанных = ЗначениеРазделителяСеанса();
			Иначе 
				Если ОбластьДанных <> ЗначениеРазделителяСеанса() Тогда
					ВызватьИсключение(НСтр("ru = 'В данном сеансе недопустимо обращение к данным из другой области данных!'"));
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		Если ОбластьДанных <> Неопределено
			И (НЕ ИспользованиеРазделителяСеанса() ИЛИ ОбластьДанных <> ЗначениеРазделителяСеанса()) Тогда
			УстановитьРазделениеСеанса(Истина, ОбластьДанных);
			ВыполненаУстановкаРазделенияСеанса = Истина;
		КонецЕсли;
	КонецЕсли;
	
	Выполнить ИмяЭкспортнойПроцедуры + "(" + ПараметрыСтрока + ")";
	
	Если ВыполненаУстановкаРазделенияСеанса Тогда
		УстановитьРазделениеСеанса(Ложь);
	КонецЕсли;
	
КонецПроцедуры


////////////////////////////////////////////////////////////////////////////////
// Имена типов.

// Возвращает значение для идентификации общего типа "Регистры сведений"
//
// Тип: Строка
//
Функция ИмяТипаРегистрыСведений() Экспорт
	
	Возврат "РегистрыСведений";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Регистры накопления"
//
// Тип: Строка
//
Функция ИмяТипаРегистрыНакопления() Экспорт
	
	Возврат "РегистрыНакопления";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Регистры бухгалтерии"
//
// Тип: Строка
//
Функция ИмяТипаРегистрыБухгалтерии() Экспорт
	
	Возврат "РегистрыБухгалтерии";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Регистры расчета"
//
// Тип: Строка
//
Функция ИмяТипаРегистрыРасчета() Экспорт
	
	Возврат "РегистрыРасчета";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Документы"
//
// Тип: Строка
//
Функция ИмяТипаДокументы() Экспорт
	
	Возврат "Документы";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Справочники"
//
// Тип: Строка
//
Функция ИмяТипаСправочники() Экспорт
	
	Возврат "Справочники";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Перечисления"
//
// Тип: Строка
//
Функция ИмяТипаПеречисления() Экспорт
	
	Возврат "Перечисления";
	
КонецФункции

// Функция-свойство: возвращает значение для идентификации общего типа "Отчеты"
//
// Тип: Строка
//
Функция ИмяТипаОтчеты() Экспорт
	
	Возврат "Отчеты";
	
КонецФункции

// Функция-свойство: возвращает значение для идентификации общего типа "Обработки"
//
// Тип: Строка
//
Функция ИмяТипаОбработки() Экспорт
	
	Возврат "Обработки";
	
КонецФункции

// Возвращает значение для идентификации общего типа "ПланыОбмена"
//
// Тип: Строка
//
Функция ИмяТипаПланыОбмена() Экспорт
	
	Возврат "ПланыОбмена";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Планы видов характеристик"
//
// Тип: Строка
//
Функция ИмяТипаПланыВидовХарактеристик() Экспорт
	
	Возврат "ПланыВидовХарактеристик";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Бизнес-процессы"
//
// Тип: Строка
//
Функция ИмяТипаБизнесПроцессы() Экспорт
	
	Возврат "БизнесПроцессы";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Задачи"
//
// Тип: Строка
//
Функция ИмяТипаЗадачи() Экспорт
	
	Возврат "Задачи";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Планы счетов"
//
// Тип: Строка
//
Функция ИмяТипаПланыСчетов() Экспорт
	
	Возврат "ПланыСчетов";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Планы видов расчета"
//
// Тип: Строка
//
Функция ИмяТипаПланыВидовРасчета() Экспорт
	
	Возврат "ПланыВидовРасчета";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Константы"
//
// Тип: Строка
//
Функция ИмяТипаКонстанты() Экспорт
	
	Возврат "Константы";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Журналы документов"
//
// Тип: Строка
//
Функция ИмяТипаЖурналыДокументов() Экспорт
	
	Возврат "ЖурналыДокументов";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Последовательности"
//
// Тип: Строка
//
Функция ИмяТипаПоследовательности() Экспорт
	
	Возврат "Последовательности";
	
КонецФункции

// Возвращает значение для идентификации общего типа "РегламентныеЗадания"
//
// Тип: Строка
//
Функция ИмяТипаРегламентныеЗадания() Экспорт
	
	Возврат "РегламентныеЗадания";
	
КонецФункции

// Устанавливает разделение сеанса.
//
// Параметры:
// Использование - Булево - Использование разделителя ОбластьДанных в сеансе
// ОбластьДанных - Число - Значение разделителя ОбластьДанных
//
Процедура УстановитьРазделениеСеанса(Знач Использование, Знач ОбластьДанных = Неопределено) Экспорт
	ПриУстановкеРазделенияСеанса(Использование, ОбластьДанных);
КонецПроцедуры

//// Возвращает значение разделителя текущей области данных.
//// В случае если значение не установлено выдается ошибка.
//// 
//// Возвращаемое значение: 
//// Тип значения разделителя.
//// Значение разделителя текущей области данных. 
//// 
Функция ЗначениеРазделителяСеанса() Экспорт
	
	Если НЕ ОбщегоНазначенияПовтИсп.РазделениеВключено() Тогда
		Возврат 0;
	Иначе
		ЗначениеРазделителя = Неопределено;
		ПриПолученииЗначенияРазделителяСеанса(ЗначениеРазделителя);
		Возврат ЗначениеРазделителя;
	КонецЕсли;
	
КонецФункции

// Возвращает флаг использования разделителя ОбластьДанных для текущего сеанса.
// 
// Возвращаемое значение: 
// Булево - Истина разделение используется, иначе нет.
// 
Функция ИспользованиеРазделителяСеанса() Экспорт
	
	ИспользованиеРазделителя = Неопределено;
	ПриПолученииИспользованияРазделителяСеанса(ИспользованиеРазделителя);
	Возврат ИспользованиеРазделителя;
	
КонецФункции

// Возвращает значение разделителя текущей области данных.
// В случае если значение не установлено выдается ошибка.
// 
// Параметры:
//  ЗначениеРазделителя - Значение разделителя текущей области данных. Возвращаемый параметр.
//           
Процедура ПриПолученииЗначенияРазделителяСеанса(ЗначениеРазделителя)
	
	Если ОбщегоНазначенияКлиентСервер.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса") Тогда
		МодульРаботаВМоделиСервиса = ОбщегоНазначенияКлиентСервер.ОбщийМодуль("РаботаВМоделиСервиса");
		ЗначениеРазделителя = МодульРаботаВМоделиСервиса.ЗначениеРазделителяСеанса();
	Иначе
		ВызватьИсключение(НСтр("ru = 'Подсистема ""Работа в модели сервиса"" не доступна'"));
	КонецЕсли;
	
КонецПроцедуры

// Возвращает флаг использования разделителя ОбластьДанных для текущего сеанса.
// 
// Параметры:
// ИспользованиеРазделителя - Булево - Истина разделение используется, иначе нет. Возвращаемый параметр.
// 
Процедура ПриПолученииИспользованияРазделителяСеанса(ИспользованиеРазделителя) Экспорт
	
	Если ОбщегоНазначенияКлиентСервер.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса") Тогда
		МодульРаботаВМоделиСервиса = ОбщегоНазначенияКлиентСервер.ОбщийМодуль("РаботаВМоделиСервиса");
		ИспользованиеРазделителя = МодульРаботаВМоделиСервиса.ИспользованиеРазделителяСеанса();
	Иначе
		ВызватьИсключение(НСтр("ru = 'Подсистема ""Работа в модели сервиса"" не доступна'"));
	КонецЕсли;
	
КонецПроцедуры

// Устанавливает разделение сеанса.
//
// Параметры:
// Использование - Булево - Использование разделителя ОбластьДанных в сеансе
// ОбластьДанных - Число - Значение разделителя ОбластьДанных
//
Процедура ПриУстановкеРазделенияСеанса(Знач Использование, Знач ОбластьДанных = Неопределено)
	
	Если ОбщегоНазначенияКлиентСервер.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса") Тогда
		Модуль = ОбщегоНазначенияКлиентСервер.ОбщийМодуль("РаботаВМоделиСервиса");
		Модуль.УстановитьРазделениеСеанса(Использование, ОбластьДанных);
	КонецЕсли;
	
КонецПроцедуры
